<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Workspaces.Desktop</name>
    </assembly>
    <members>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.s_utf8Encoding">
            <summary>
            Encoding to use when there is no byte order mark (BOM) on the stream. This encoder may throw a <see cref="T:System.Text.DecoderFallbackException"/>
            if the stream contains invalid UTF-8 bytes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.s_fallbackEncoding">
            <summary>
            Encoding to use when UTF-8 fails. We try to find the following, in order, if available:
                1. The default ANSI codepage
                2. CodePage 1252.
                3. Latin1.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Create(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the provided stream. This version differs
            from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)"/> in two ways:
            1. It attempts to minimize allocations by trying to read the stream into a byte array.
            2. If <paramref name="defaultEncoding"/> is null, it will first try UTF8 and, if that fails, it will
               try CodePage 1252. If CodePage 1252 is not available on the system, then it will try Latin1.
            </summary>
            <param name="stream">The stream containing encoded text.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be Encoding.Default.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <param name="canBeEmbedded">Indicates if the file can be embedded in the PDB.</param>
            <param name="checksumAlgorithm">Hash algorithm used to calculate document checksum.</param>
            <exception cref="T:System.IO.InvalidDataException">
            The stream content can't be decoded using the specified <paramref name="defaultEncoding"/>, or
            <paramref name="defaultEncoding"/> is null and the stream appears to be a binary file.
            </exception>
            <exception cref="T:System.IO.IOException">An IO error occurred while reading from the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Decode(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean,System.Boolean)">
            <summary>
            Try to create a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the given stream using the given encoding.
            </summary>
            <param name="data">The input stream containing the encoded text. The stream will not be closed.</param>
            <param name="encoding">The expected encoding of the stream. The actual encoding used may be different if byte order marks are detected.</param>
            <param name="checksumAlgorithm">The checksum algorithm to use.</param>
            <param name="throwIfBinaryDetected">Throw <see cref="T:System.IO.InvalidDataException"/> if binary (non-text) data is detected.</param>
            <param name="canBeEmbedded">Indicates if the text can be embedded in the PDB.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> decoded from the stream.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">The decoder was unable to decode the stream with the given encoding.</exception>
            <exception cref="T:System.IO.IOException">Error reading from stream.</exception> 
            <remarks>
            internal for unit testing
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromStream(System.IO.Stream,System.ArraySegment{System.Byte}@)">
            <summary>
            Some streams are easily represented as bytes.
            </summary>
            <param name="data">The stream</param>
            <param name="bytes">The bytes, if available.</param>
            <returns>
            True if the stream's bytes could easily be read, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromFileStream(System.IO.FileStream,System.ArraySegment{System.Byte}@)">
            <summary>
            Read the contents of a FileStream into a byte array.
            </summary>
            <param name="stream">The FileStream with encoded text.</param>
            <param name="bytes">A byte array filled with the contents of the file.</param>
            <returns>True if a byte array could be created.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CoreClrShim">
            <summary>
            Shim for APIs available only on CoreCLR.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DesktopAnalyzerAssemblyLoader">
            <summary>
            Loads analyzer assemblies from their original locations in the file system.
            Assemblies will only be loaded from the locations specified when the loader
            is instantiated.
            </summary>
            <remarks>
            This type is meant to be used in scenarios where it is OK for the analyzer
            assemblies to be locked on disk for the lifetime of the host; for example,
            csc.exe and vbc.exe. In scenarios where support for updating or deleting
            the analyzer on disk is required a different loader should be used.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.DesktopReferenceSerializationServiceFactory">
            <summary>
            this is desktop implementation of IReferenceSerializationService
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.SerializationAnalyzerAssemblyLoader">
            <summary>
            This is assembly loader for serialized analyzer reference. 
            
            this will record display path (<see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.FullPath"/>  returns) and 
            actual path (<see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.GetAssembly"/> ) assembly needed to be loaded 
            
            when requested, it will load from actual path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EtwLogger">
            <summary>
            A logger that publishes events to ETW using an EventSource.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource">
            <summary>
            This EventSource exposes our events to ETW.
            RoslynEventSource GUID is {bf965e67-c7fb-5c5b-d98f-cdf68f8154c2}.
            
            When updating this class, use the following to also update Main\Source\Test\Performance\Log\RoslynEventSourceParser.cs:
            Main\Tools\Source\TraceParserGen\bin\Debug\TraceParserGen.exe Microsoft.CodeAnalysis.Workspaces.dll -eventsource:RoslynEventSource
            
            Use this command to register the ETW manifest on any machine where you need to decode events in xperf/etlstackbrowse:
            "\\clrmain\tools\managed\etw\eventRegister\bin\Debug\eventRegister.exe" Microsoft.CodeAnalysis.Workspaces.dll
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspaceDesktopResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Invalid_assembly_name">
            <summary>
              Looks up a localized string similar to Invalid assembly name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Invalid_characters_in_assembly_name">
            <summary>
              Looks up a localized string similar to Invalid characters in assembly name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Msbuild_failed_when_processing_the_file_0">
            <summary>
              Looks up a localized string similar to Msbuild failed when processing the file &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Msbuild_failed_when_processing_the_file_0_with_message_1">
            <summary>
              Looks up a localized string similar to Msbuild failed when processing the file &apos;{0}&apos; with message: {1}.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> structure initialized from a compilers command line arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> structure initialized with data from a compiler command line.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FileTextLoaderOptions.FileLengthThreshold">
            <summary>
            Hidden registry key to control maximum size of a text file we will read into memory. 
            we have this option to reduce a chance of OOM when user adds massive size files to the solution.
            Default threshold is 100MB which came from some internal data on big files and some discussion.
            
            User can override default value by setting DWORD value on FileLengthThreshold in 
            "[VS HIVE]\Roslyn\Internal\Performance\Text"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Creates a content loader for specified file.
            </summary>
            <param name="path">An absolute file path.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be <see cref="P:System.Text.Encoding.Default"/>.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is not an absolute path.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.Path">
            <summary>
            Absolute path of the file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.DefaultEncoding">
            <summary>
            Specifies an encoding to be used if the actual encoding of the file 
            can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If <c>null</c> auto-detect heuristics are used to determine the encoding. 
            If these heuristics fail the decoding is assumed to be <see cref="P:System.Text.Encoding.Default"/>.
            Note that if the stream starts with Byte Order Mark the value of <see cref="P:Microsoft.CodeAnalysis.FileTextLoader.DefaultEncoding"/> is ignored.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.LoadTextAndVersionAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document in the workspace.
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.LoadTextAndVersionSynchronously(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document in the workspace.
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices">
            <summary>
            A class that provides host services via classes instances exported via a MEF version 1 composition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.CreateWorkspaceServices(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> associated with the specified workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.GetExports``2">
            <summary>
            Gets all the MEF exports of the specified type with the specified metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.GetExports``1">
            <summary>
            Gets all the MEF exports of the specified type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService">
            <summary>
            Temporarily stores text and streams in memory mapped files.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.SingleFileThreshold">
            <summary>
            The maximum size in bytes of a single storage unit in a memory mapped file which is shared with other
            storage units.
            </summary>
            <remarks>
            <para>This value was arbitrarily chosen and appears to work well. Can be changed if data suggests
            something better.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.MultiFileBlockSize">
            <summary>
            The size in bytes of a memory mapped file created to store multiple temporary objects.
            </summary>
            <remarks>
            <para>This value was arbitrarily chosen and appears to work well. Can be changed if data suggests
            something better.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate">
            <summary>
            The synchronization object for accessing the memory mapped file related fields (indicated in the remarks
            of each field).
            </summary>
            <remarks>
            <para>PERF DEV NOTE: A concurrent (but complex) implementation of this type with identical semantics is
            available in source control history. The use of exclusive locks was not causing any measurable
            performance overhead even on 28-thread machines at the time this was written.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference">
            <summary>
            The most recent memory mapped file for creating multiple storage units. It will be used via bump-pointer
            allocation until space is no longer available in it.
            </summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._name">
            <summary>The name of the current memory mapped file for multiple storage units.</summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._fileSize">
            <summary>The total size of the current memory mapped file for multiple storage units.</summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._offset">
            <summary>
            The offset into the current memory mapped file where the next storage unit can be held.
            </summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.CreateTemporaryStorage(System.Int64)">
            <summary>
            Allocate shared storage of a specified size.
            </summary>
            <remarks>
            <para>"Small" requests are fulfilled from oversized memory mapped files which support several individual
            storage units. Larger requests are allocated in their own memory mapped files.</para>
            </remarks>
            <param name="size">The size of the shared storage block to allocate.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/> describing the allocated block.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo">
             <summary>
             Our own abstraction on top of memory map file so that we can have shared views over mmf files. 
             Otherwise, each view has minimum size of 64K due to requirement forced by windows.
             
             most of our view will have short lifetime, but there are cases where view might live a bit longer such as
             metadata dll shadow copy. shared view will help those cases.
             </summary>
             <remarks>
             <para>Instances of this class should be disposed when they are no longer needed. After disposing this
             instance, it should no longer be used. However, streams obtained through <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream"/>
             or <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream"/> will not be invalidated until they are disposed independently (which
             may occur before or after the <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/> is disposed.</para>
            
             <para>This class and its nested types have familiar APIs and predictable behavior when used in other code,
             but are non-trivial to work on. The implementations of <see cref="T:System.IDisposable"/> adhere to the best
             practices described in
             <see href="http://joeduffyblog.com/2005/04/08/dg-update-dispose-finalization-and-resource-management/">DG
             Update: Dispose, Finalization, and Resource Management</see>. Additional notes regarding operating system
             behavior leveraged for efficiency are given in comments.</para>
             </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo._memoryMappedFile">
            <summary>
            The memory mapped file.
            </summary>
            <remarks>
            <para>It is possible for this accessor to be disposed prior to the view and/or the streams which use it.
            However, the operating system does not actually close the views which are in use until the view handles
            are closed as well, even if the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile"/> is disposed first.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo._weakReadAccessor">
             <summary>
             A weak reference to a read-only view for the memory mapped file.
             </summary>
             <remarks>
             <para>This holds a weak counted reference to current <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor"/>, which
             allows additional accessors for the same address space to be obtained up until the point when no
             external code is using it. When the memory is no longer being used by any
             <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream"/> objects, the view of the memory mapped file is unmapped, making the
             process address space it previously claimed available for other purposes. If/when it is needed again, a
             new view is created.</para>
            
             <para>This view is read-only, so it is only used by <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream"/>.</para>
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.Name">
            <summary>
            The name of the memory mapped file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.Offset">
            <summary>
            The offset into the memory mapped file of the region described by the current
            <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.Size">
            <summary>
            The size of the region of the memory mapped file described by the current
            <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will not increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.RunWithCompactingGCFallback``2(System.Func{``0,``1},``0)">
            <summary>
            Run a function which may fail with an <see cref="T:System.IO.IOException"/> if not enough memory is available to
            satisfy the request. In this case, a full compacting GC pass is forced and the function is attempted
            again.
            </summary>
            <remarks>
            <para><see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)"/> and
            <see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)"/> will use a native
            memory map, which can't trigger a GC. In this case, we'd otherwise crash with OOM, so we don't care
            about creating a UI delay with a full forced compacting GC. If it crashes the second try, it means we're
            legitimately out of resources.</para>
            </remarks>
            <typeparam name="TArg">The type of argument to pass to the callback.</typeparam>
            <typeparam name="T">The type returned by the function.</typeparam>
            <param name="function">The function to execute.</param>
            <param name="argument">The argument to pass to the function.</param>
            <returns>The value returned by <paramref name="function"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream.GetPointer">
            <summary>
            Get underlying native memory directly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1">
             <summary>
             A reference-counting wrapper which allows multiple uses of a single disposable object in code, which is
             deterministically released (by calling <see cref="M:System.IDisposable.Dispose"/>) when the last reference is
             disposed.
             </summary>
             <remarks>
             <para>Each instance of <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1"/> represents a counted reference (also
             referred to as a <em>reference</em> in the following documentation) to a target object. Each of these
             references has a lifetime, starting when it is constructed and continuing through its release. During
             this time, the reference is considered <em>alive</em>. Each reference which is alive owns exactly one
             reference to the target object, ensuring that it will not be disposed while still in use. A reference is
             released through either of the following actions:</para>
            
             <list type="bullet">
             <item>The reference is explicitly released by a call to <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.Dispose"/>.</item>
             <item>The reference is no longer in use by managed code and gets reclaimed by the garbage collector.</item>
             </list>
            
             <para>While each instance of <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1"/> should be explicitly disposed when
             the object is no longer needed by the code owning the reference, this implementation will not leak resources
             in the event one or more callers fail to do so. When all references to an object are explicitly released
             (i.e. by calling <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.Dispose"/>), the target object will itself be deterministically released by a
             call to <see cref="M:System.IDisposable.Dispose"/> when the last reference to it is released. However, in the event
             one or more references is not explicitly released, the underlying object will still become eligible for
             non-deterministic release (i.e. finalization) as soon as each reference to it is released by one of the
             two actions described previously.</para>
            
             <para>When using <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1"/>, certain steps must be taken to ensure the
             target object is not disposed early.</para>
            
             <list type="number">
             <para>Use <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1"/> consistently. In other words, do not mix code using
             reference-counted wrappers with code that references to the target directly.</para>
             <para>Only use the <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.#ctor(`0)"/> constructor one time per target object.
             Additional references to the same target object must only be obtained by calling
             <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.TryAddReference"/>.</para>
             <para>Do not call <see cref="M:System.IDisposable.Dispose"/> on the target object directly. It will be called
             automatically at the appropriate time, as described above.</para>
             </list>
            
             <para>All public methods on this type adhere to their pre- and post-conditions and will not invalidate state
             even in concurrent execution.</para>
             </remarks>
             <typeparam name="T">The type of disposable object.</typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1._instance">
            <summary>
            The target of this reference. This value is initialized to a non-<see langword="null"/> value in the
            constructor, and set to <see langword="null"/> when the current reference is disposed.
            </summary>
            <remarks>
            <para>This value is only cleared in order to support cases where one or more references is garbage
            collected without having <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.Dispose"/> called.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1._boxedReferenceCount">
             <summary>
             The boxed reference count, which is shared by all references with the same <see cref="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.Target"/> object.
             </summary>
             <remarks>
             <para>This field serves as the synchronization object for the current type, since it is shared among all
             counted reference to the same target object. Accesses to <see cref="F:System.Runtime.CompilerServices.StrongBox`1.Value"/> should only
             occur when this object is locked.</para>
            
             <para>PERF DEV NOTE: A concurrent (but complex) implementation of this type with identical semantics is
             available in source control history. The use of exclusive locks was not causing any measurable
             performance overhead even on 28-thread machines at the time this was written.</para>
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.#ctor(`0)">
            <summary>
            Initializes a new reference counting wrapper around an <see cref="T:System.IDisposable"/> object.
            </summary>
            <remarks>
            <para>The reference count is initialized to 1.</para>
            </remarks>
            <param name="instance">The object owned by this wrapper.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="instance"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.Target">
            <summary>
            Gets the target object.
            </summary>
            <remarks>
            <para>This call is not valid after <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.Dispose"/> is called. If this property or the target
            object is used concurrently with a call to <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.Dispose"/>, it is possible for the code to be
            using a disposed object. After the current instance is disposed, this property throws
            <see cref="T:System.ObjectDisposedException"/>. However, the exact time when this property starts throwing after
            <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.Dispose"/> is called is unspecified; code is expected to not use this property or the object
            it returns after any code invokes <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.Dispose"/>.</para>
            </remarks>
            <value>The target object.</value>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.TryAddReference">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <returns>A new <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed; otherwise, <see langword="null"/> if this reference to the underlying object
            has already been disposed.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.TryAddReferenceImpl(`0,System.Runtime.CompilerServices.StrongBox{System.Int32})">
            <summary>
            Provides the implementation for <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.TryAddReference"/> and
            <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.WeakReference.TryAddReference"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.Dispose">
            <summary>
            Releases the current reference, causing the underlying object to be disposed if this was the last
            reference.
            </summary>
            <remarks>
            <para>After this instance is disposed, the <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.TryAddReference"/> method can no longer be used to
            object a new reference to the target, even if other references to the target object are still in
            use.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.WeakReference">
            <summary>
            Represents a weak reference to a <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1"/> which is capable of
            obtaining a new counted reference up until the point when the object is no longer accessible.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.WeakReference._weakInstance">
            <summary>
            DO NOT DISPOSE OF THE TARGET.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.WeakReference.TryAddReference">
             <summary>
             Increments the reference count for the disposable object, and returns a new disposable reference to
             it.
             </summary>
             <remarks>
             <para>Unlike <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1.TryAddReference"/>, this method is capable of
             adding a reference to the underlying instance all the way up to the point where it is finally
             disposed.</para>
            
             <para>The returned object is an independent reference to the same underlying object. Disposing of
             the returned value multiple times will only cause the reference count to be decreased once.</para>
             </remarks>
             <returns>A new <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.ReferenceCountedDisposable`1"/> pointing to the same underlying object,
             if it has not yet been disposed; otherwise, <see langword="null"/> if the underlying object has
             already been disposed.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace">
            <summary>
            A workspace that can be populated by opening MSBuild solution and project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
            <param name="properties">An optional set of MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create(Microsoft.CodeAnalysis.Host.HostServices)">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
            <param name="hostServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostServices"/> used to configure this workspace.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create(System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.CodeAnalysis.Host.HostServices)">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
            <param name="properties">The MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.</param>
            <param name="hostServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostServices"/> used to configure this workspace.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Properties">
            <summary>
            The MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Diagnostics">
            <summary>
            Diagnostics logged while opening solutions, projects and documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.LoadMetadataForReferencedProjects">
            <summary>
            Determines if metadata from existing output assemblies is loaded instead of opening referenced projects.
            If the referenced project is already opened, the metadata will not be loaded.
            If the metadata assembly cannot be found the referenced project will be opened instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.SkipUnrecognizedProjects">
            <summary>
            Determines if unrecognized projects are skipped when solutions or projects are opened.
            
            An project is unrecognized if it either has 
              a) an invalid file path, 
              b) a non-existent project file,
              c) has an unrecognized file extension or 
              d) a file extension associated with an unsupported language.
            
            If unrecognized projects cannot be skipped a corresponding exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.AssociateFileExtensionWithLanguage(System.String,System.String)">
            <summary>
            Associates a project file extension with a language name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.CloseSolution">
            <summary>
            Close the open solution, and reset the workspace to a new empty solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.OpenSolutionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Open a solution file and all referenced projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.OpenProjectAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Open a project file and all referenced projects.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo">
            <summary>
            Represents a source file that is part of a project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.FilePath">
            <summary>
            The absolute path to the document file on disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.LogicalPath">
            <summary>
            A fictional path to the document, relative to the project.
            The document may not actually exist at this location, and is used
            to represent linked documents. This includes the file name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.IsLinked">
            <summary>
            True if the document has a logical path that differs from its 
            absolute file path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.IsGenerated">
            <summary>
            True if the file was generated during build.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.IProjectFile">
            <summary>
            Represents a project file loaded from disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.IProjectFile.FilePath">
            <summary>
            The path to the project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.IProjectFile.ErrorMessage">
            <summary>
            The error message produced when a failure occurred attempting to access the project file. 
            If a failure occurred the projectd file info will be inaccessible.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetProjectFileInfoAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the project file info asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetSourceCodeKind(System.String)">
            <summary>
            Get the kind of source found in the specified file. 
            This is usually determined by the file name extension.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetDocumentExtension(Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Gets the corresponding extension for a source file of a given kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.AddDocument(System.String,System.String)">
            <summary>
            Add a source document to a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.RemoveDocument(System.String)">
            <summary>
            Remove a source document from a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.AddMetadataReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
             Add a metadata reference to a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.RemoveMetadataReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Remove a metadata reference from a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.AddProjectReference(System.String,Microsoft.CodeAnalysis.MSBuild.ProjectFileReference)">
            <summary>
            Add a reference to another project to a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.RemoveProjectReference(System.String,System.String)">
            <summary>
            Remove a reference to another project from a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.AddAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Add an analyzer reference to the project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.RemoveAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Remove an analyzer reference from the project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.Save">
            <summary>
            Save the current state of the project file to disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.ProjectFile.CreateProjectFileReference(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference"/> from a ProjectReference node in the MSBuild file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.ProjectFile.GetAbsolutePath(System.String)">
            <summary>
            Resolves the given path that is possibly relative to the project directory.
            </summary>
            <remarks>
            The resulting path is absolute but might not be normalized.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo">
            <summary>
            Represents a project file loaded from disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.OutputFilePath">
            <summary>
            The path to the output file this project generates.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.AssemblyName">
            <summary>
            The assembly name of the output.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.CommandLineArgs">
            <summary>
            The command line args used to compile the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.Documents">
            <summary>
            The source documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.AdditionalDocuments">
            <summary>
            The additional documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.ProjectReferences">
            <summary>
            References to other projects.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.ErrorMessage">
            <summary>
            The error message produced when a failure occurred attempting to get the info. 
            If a failure occurred some or all of the information may be inaccurate or incomplete.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference">
            <summary>
            Represents a reference to another project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference.Path">
            <summary>
            The path on disk to the other project file. 
            This path may be relative to the referencing project's file or an absolute path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference.Aliases">
            <summary>
            The aliases assigned to this reference, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.SectionBlock">
            <summary>
            Represents a SectionBlock in a .sln file. Section blocks are of the form:
            
            Type(ParenthesizedName) = Value
                Key = Value
                [more keys/values]
            EndType
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader">
            <summary>
            An API for loading msbuild project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.#ctor(Microsoft.CodeAnalysis.Workspace,System.Collections.Immutable.ImmutableDictionary{System.String,System.String})">
            <summary>
            Create a new instance of an <see cref="T:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.Properties">
            <summary>
            The MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadMetadataForReferencedProjects">
            <summary>
            Determines if metadata from existing output assemblies is loaded instead of opening referenced projects.
            If the referenced project is already opened, the metadata will not be loaded.
            If the metadata assembly cannot be found the referenced project will be opened instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.SkipUnrecognizedProjects">
            <summary>
            Determines if unrecognized projects are skipped when solutions or projects are opened.
            
            A project is unrecognized if it either has 
              a) an invalid file path, 
              b) a non-existent project file,
              c) has an unrecognized file extension or 
              d) a file extension associated with an unsupported language.
            
            If unrecognized projects cannot be skipped a corresponding exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.AssociateFileExtensionWithLanguage(System.String,System.String)">
            <summary>
            Associates a project file extension with a language name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadSolutionInfoAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Loads the <see cref="T:Microsoft.CodeAnalysis.SolutionInfo"/> for the specified solution file, including all projects referenced by the solution file and 
            all the projects referenced by the project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadProjectInfoAsync(System.String,System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ProjectId},System.Threading.CancellationToken)">
            <summary>
            Loads the <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> from the specified project file and all referenced projects.
            The first <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> in the result corresponds to the specified project file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadState._projectAlreadyReferencesProjectResultCache">
            <summary>
            Used to memoize results of <see cref="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadState.ProjectAlreadyReferencesProject(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)"/> calls.
            Reset any time internal state is changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadState.ProjectAlreadyReferencesProject(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Returns true if the project identified by <paramref name="fromProject"/> has a reference (even indirectly)
            on the project identified by <paramref name="targetProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.GetProjectMetadata(System.String,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Gets a MetadataReference to a project's output assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionSize.SolutionSizeTracker">
            <summary>
            Track approximate solution size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionSize.SolutionSizeTracker.GetSolutionSize(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.SolutionId)">
            <summary>
            Get approximate solution size at the point of call.
            
            This API is not supposed to return 100% accurate size. 
            
            if a feature require 100% accurate size, use Solution to calculate it. this API is supposed to
            lazy and very cheap on answering that question.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement">
             <summary>
             Simple wrapper struct for a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/> that helps ensure that the statement
             is always <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset"/> after it is used.
             
             See https://sqlite.org/c3ref/stmt.html:
             The life-cycle of a prepared statement object usually goes like this:
                1) Create the prepared statement object using sqlite3_prepare_v2().
                2) Bind values to parameters using the sqlite3_bind_* () interfaces.
                3) Run the SQL by calling sqlite3_step() one or more times.
                4) Reset the prepared statement using sqlite3_reset() then go back to step 2. Do this zero or more times.
                5) Destroy the object using sqlite3_finalize().
            
             This type helps ensure that '4' happens properly by clients executing statement.
             Note that destroying/finalizing a statement is not the responsibility of a client
             as it will happen to all prepared statemnets when the <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/> is
             <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Close_OnlyForUseBySqlConnection"/>d.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection">
            <summary>
            Encapsulates a connection to a sqlite database.  On construction an attempt will be made
            to open the DB if it exists, or create it if it does not.
            
            Connections are considered relatively heavyweight and are pooled until the <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage"/>
            is <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Close"/>d.  Connections can be used by different threads,
            but only as long as they are used by one thread at a time.  They are not safe for concurrent
            use by several threads.
            
            <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/>s can be created through the user of <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.GetResettableStatement(System.String)"/>.
            These statements are cached for the lifetime of the connection and are only finalized
            (i.e. destroyed) when the connection is closed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._handle">
            <summary>
            The raw handle to the underlying DB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._faultInjector">
            <summary>
            For testing purposes to simulate failures during testing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._queryToStatement">
            <summary>
            Our cache of prepared statements for given sql strings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.IsInTransaction">
            <summary>
            Whether or not we're in a transaction.  We currently don't supported nested transactions.
            If we want that, we can achieve it through sqlite "save points".  However, that's adds a 
            lot of complexity that is nice to avoid.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement">
            <summary>
            Represents a prepared sqlite statement.  <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/>s can be 
            <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Step(System.Boolean)"/>ed (i.e. executed).  Executing a statement can result in 
            either <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.DONE"/> if the command completed and produced no
            value, or <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.ROW"/> if it evaluated out to a sql row that can
            then be queried.
            
            If a statement is parameterized then parameters can be provided by the 
            BindXXX overloads.  Bind is 1-based (to match sqlite).  
            
            When done executing a statement, the statement should be <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset"/>.
            The easiest way to ensure this is to just use a 'using' statement along with
            a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement"/>.  By resetting the statement, it can
            then be used in the future with new bound parameters.
            
            Finalization/destruction of the underlying raw sqlite statement is handled
            by <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.Close_OnlyForUseBySqlPersistentStorage"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage">
            <summary>
            Implementation of an <see cref="T:Microsoft.CodeAnalysis.Host.IPersistentStorage"/> backed by SQLite.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3">
            <summary>
            Abstracts out access to specific tables in the DB.  This allows us to share overall
            logic around cancellation/pooling/error-handling/etc, while still hitting different
            db tables.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3._writeQueueKeyToWrites">
            <summary>
            Queue of actions we want to perform all at once against the DB in a single transaction.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3._writeQueueKeyToWriteTask">
            <summary>
            The task responsible for writing out all the batched actions we have for a particular
            queue.  When new reads come in for that queue they can 'await' this write-task completing
            so that all reads for the queue observe any previously completed writes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.StringInfoTableName">
            <summary>
            Inside the DB we have a table dedicated to storing strings that also provides a unique 
            integral ID per string.  This allows us to store data keyed in a much more efficient
            manner as we can use those IDs instead of duplicating strings all over the place.  For
            example, there may be many pieces of data associated with a file.  We don't want to 
            key off the file path in all these places as that would cause a large amount of bloat.
            
            Because the string table can map from arbitrary strings to unique IDs, it can also be
            used to create IDs for compound objects.  For example, given the IDs for the FilePath
            and Name of a Project, we can get an ID that represents the project itself by just
            creating a compound key of those two IDs.  This ID can then be used in other compound
            situations.  For example, a Document's ID is creating by compounding its Project's 
            ID, along with the IDs for the Document's FilePath and Name.
            
            The format of the table is:
            
             StringInfo
             --------------------------------------------------------------
             | Id (integer, primary key, auto increment) | Data (varchar) |
             --------------------------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionDataTableName">
            <summary>
            Inside the DB we have a table for data corresponding to the <see cref="T:Microsoft.CodeAnalysis.Solution"/>.  The 
            data is just a blob that is keyed by a string Id.  Data with this ID can be retrieved
            or overwritten.
            
            The format of the table is:
            
             SolutionData
             -----------------------------------------------
             | DataId (primary key, varchar) | Data (blob) |
             -----------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectDataTableName">
            <summary>
            Inside the DB we have a table for data that we want associated with a <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            The data is keyed off of an integral value produced by combining the ID of the Project and
            the ID of the name of the data (see <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Project,System.String,System.Threading.CancellationToken)"/>.
            
            This gives a very efficient integral key, and means that the we only have to store a 
            single mapping from stream name to ID in the string table.
            
            The format of the table is:
            
             ProjectData
             -----------------------------------------------
             | DataId (primary key, integer) | Data (blob) |
             -----------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentDataTableName">
            <summary>
            Inside the DB we have a table for data that we want associated with a <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            The data is keyed off of an integral value produced by combining the ID of the Document and
            the ID of the name of the data (see <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Document,System.String,System.Threading.CancellationToken)"/>.
            
            This gives a very efficient integral key, and means that the we only have to store a 
            single mapping from stream name to ID in the string table.
            
            The format of the table is:
            
             DocumentData
             ----------------------------------------------
             | DataId (primary key, integer) | Data (blob) |
             ----------------------------------------------
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentDataTableName"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._projectIdToIdMap">
            <summary>
            Mapping from the workspace's ID for a project, to the ID we use in the DB for the project.
            Kept locally so we don't have to hit the DB for the common case of trying to determine the 
            DB id for a project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.TryGetProjectDataId(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Project,System.String,System.Int64@)">
            <summary>
            Given a project, and the name of a stream to read/write, gets the integral DB ID to 
            use to find the data inside the ProjectData table.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectDataTableName"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.FlushAllDelayMS">
            <summary>
            Amount of time to wait between flushing writes to disk.  500ms means we can flush
            writes to disk two times a second.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.MaxPooledByteArrayLength">
            <summary>
            We use a pool to cache reads/writes that are less than 4k.  Testing with Roslyn,
            99% of all writes (48.5k out of 49.5k) are less than that size.  So this helps
            ensure that we can pool as much as possible, without caching excessively large 
            arrays (for example, Roslyn does write out nearly 50 chunks that are larger than
            100k each).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.MaxPooledByteArrays">
            <summary>
            The max amount of byte[]s we cache.  This caps our cache at 4MB while allowing
            us to massively speed up writing (by batching writes).  Because we can write to
            disk two times a second.  That means a total of 8MB/s that can be written to disk
            using only our cache.  Given that Roslyn itself only writes about 50MB to disk
            after several minutes of analysis, this amount of bandwidth is more than sufficient.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._documentIdToIdMap">
            <summary>
            Mapping from the workspace's ID for a document, to the ID we use in the DB for the document.
            Kept locally so we don't have to hit the DB for the common case of trying to determine the 
            DB id for a document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.TryGetDocumentDataId(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Document,System.String,System.Int64@)">
            <summary>
            Given a document, and the name of a stream to read/write, gets the integral DB ID to 
            use to find the data inside the DocumentData table.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionDataTableName"/>.  Note that with the Solution 
            table there is no need for key->id translation.  i.e. the key acts as the ID itself.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._writeQueueGate">
            <summary>
            Lock protecting the write queues and <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._flushAllTask"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._flushAllTask">
            <summary>
            Task kicked off to actually do the work of flushing all data to the DB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.BulkPopulateIds(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Solution,System.Boolean)">
            <remarks>
            We have a lot of ID information to put into the DB. IDs for all strings we intend to 
            intern, as well as compound IDs for our projects and documents. Inserting these 
            individually is far too slow as SQLite will lock the DB for each insert and will have
            to do all the journalling work to ensure ACID semantics.  To avoid that, we attempt
            to precompute all the information we'd need to put in the ID tables and perform it
            all at once per project.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.BulkPopulateProjectIdsWorker(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Project)">
            <summary>
            Returns 'true' if the bulk population succeeds, or false if it doesn't.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService">
            <summary>
            A service that enables storing and retrieving of information associated with solutions,
            projects or documents across runtime sessions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Storage.StorageOptions.SolutionSizeThreshold">
            <summary>
            Solution size threshold to start to use a DB (Default: 50MB)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.TryReadAll(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Attempts to read all of the requested bytes from the stream into the buffer
            </summary>
            <returns>
            The number of bytes read. Less than <paramref name="count" /> will
            only be returned if the end of stream is reached before all bytes can be read.
            </returns>
            <remarks>
            Unlike <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> it is not guaranteed that
            the stream position or the output buffer will be unchanged if an exception is
            returned.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.ReadAllBytes(System.IO.Stream)">
            <summary>
            Reads all bytes from the current postion of the given stream to its end.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EncodingExtensions.GetMaxCharCountOrThrowIfHuge(System.Text.Encoding,System.IO.Stream)">
            <summary>
            Get maximum char count needed to decode the entire stream.
            </summary>
            <exception cref="T:System.IO.IOException">Stream is so big that max char count can't fit in <see cref="T:System.Int32"/>.</exception> 
        </member>
        <member name="F:Roslyn.Utilities.FileKey.FullPath">
            <summary>
            Full case-insensitive path.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.Timestamp">
            <summary>
            Last write time (UTC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.#ctor(System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="fullPath">Full path.</param>
            <param name="timestamp">Last write time (UTC).</param>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.Create(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
    </members>
</doc>
